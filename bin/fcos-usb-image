#!/usr/bin/env bash
# Build a bootable Fedora CoreOS disk image for running directly from USB.
#
# This creates:
#  - an Ignition config that creates a user with SSH keys + password hash
#  - a raw disk image installed via coreos-installer (written to a loop device)

set -euo pipefail
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)
# shellcheck source=../lib/common.sh disable=SC1091
. "$SCRIPT_DIR/../lib/common.sh"

OUT_DIR=""
STREAM="stable"
ARCH="x86_64"
PLATFORM="metal"
DISK_SIZE_GIB=16
USERNAME="${USER:-core}"
HOSTNAME=""
REPO_URL="https://github.com/jstamagal/cloud-native.git"
REPO_REF="main"
PASSWORD_HASH=""
PROMPT_PASSWORD=0
SSH_KEYS=()
DO_BUILD=1
RUN_QEMU=0
QEMU_GUI=0
QEMU_NO_KVM=0
QEMU_NO_SNAPSHOT=0
QEMU_SSH_PORT=2222
QEMU_MEM_MB=4096
QEMU_CPUS=4
QEMU_NAME="fcos-usb-debug"
QEMU_EXTRA=()

usage() {
  cat <<EOF
fcos-usb-image [options]

Creates a bootable FCOS raw disk image suitable for writing to a USB stick.

Options:
  --out DIR               output directory (default: ./out/fcos-usb-<user>)
  --stream NAME           FCOS stream (default: stable)
  --arch ARCH             target arch (default: x86_64)
  --platform NAME         ignition platform id (default: metal)
  --size-gib N            disk image size in GiB (default: 16)

  --user NAME             username to create (default: $USERNAME)
  --hostname NAME         optional hostname to set
  --ssh-key PATH          add SSH public key file (repeatable)

  --password              prompt for a login password and hash it (requires openssl)
  --password-hash HASH    provide an existing password hash (preferred for automation)

  --repo URL              repo to clone on first boot (default: $REPO_URL)
  --ref REF               git ref/branch to checkout (default: $REPO_REF)

  --no-build              only generate ignition.json; do not build a raw image

QEMU helpers (when --run-qemu is set):
  --run-qemu              launch QEMU after building the image
  --qemu-gui              open a QEMU display window (default: console)
  --qemu-no-kvm           force TCG (software) if KVM is unavailable
  --qemu-no-snapshot      persist writes to the base image (default: snapshot=on)
  --qemu-ssh-port PORT    host port forwarded to guest 22 (default: $QEMU_SSH_PORT, 0 disables)
  --qemu-memory MB        guest RAM in MiB (default: $QEMU_MEM_MB)
  --qemu-cpus N           vCPUs (default: $QEMU_CPUS)
  --qemu-name NAME        QEMU VM/process name (default: $QEMU_NAME)
  --                      pass remaining args straight to bin/fcos-usb-qemu

Notes:
  - This does NOT copy private SSH keys.
  - Building the raw image requires root (loop device + coreos-installer).
  - If the `coreos-installer` binary is not installed, we transparently fall back to
    the official container image via podman (requires privileged podman).
EOF
  exit 1
}

prompt_password_hash() {
  ensure_commands openssl stty

  pass1=""
  pass2=""

  printf "Password for %s: " "$USERNAME" >&2
  stty -echo </dev/tty
  IFS= read -r pass1 </dev/tty
  stty echo </dev/tty
  printf "\n" >&2

  printf "Confirm password: " >&2
  stty -echo </dev/tty
  IFS= read -r pass2 </dev/tty
  stty echo </dev/tty
  printf "\n" >&2

  [ "$pass1" = "$pass2" ] || die "passwords did not match"
  [ -n "$pass1" ] || die "empty password not allowed"

  # SHA-512 crypt.
  PASSWORD_HASH=$(printf "%s\n" "$pass1" | openssl passwd -6 -stdin)
}

add_default_ssh_keys() {
  # Add all public keys under ~/.ssh if no keys were explicitly provided.
  [ "${#SSH_KEYS[@]}" -gt 0 ] && return 0
  for f in "${HOME:-/dev/null}/.ssh"/*.pub; do
    [ -f "$f" ] && SSH_KEYS+=("$f")
  done
}

json_escape() {
  # Minimal JSON string escaper.
  # Usage: json_escape "string"
  s=$1
  s=${s//\\/\\\\}
  s=${s//\"/\\\"}
  s=${s//$'\n'/\\n}
  s=${s//$'\r'/\\r}
  s=${s//$'\t'/\\t}
  printf "%s" "$s"
}

b64_file() {
  # base64 without line wraps (GNU and busybox compatible-ish)
  if base64 --help 2>/dev/null | grep -q -- "-w"; then
    base64 -w0 "$1"
  else
    base64 "$1" | tr -d '\n'
  fi
}

escape_for_dq() {
  # Escape a string for safe use inside double quotes.
  local s=${1//\\/\\\\}
  s=${s//\"/\\\"}
  printf "%s" "$s"
}

write_ignition() {
  mkdir -p "$OUT_DIR"

  add_default_ssh_keys
  [ "${#SSH_KEYS[@]}" -gt 0 ] || die "no SSH public keys found; pass --ssh-key ~/.ssh/id_ed25519.pub"
  [ -n "$PASSWORD_HASH" ] || die "password hash missing (use --password or --password-hash)"

  ssh_json=""
  for k in "${SSH_KEYS[@]}"; do
    [ -f "$k" ] || die "ssh key not found: $k"
    key_contents=$(cat "$k")
    key_contents=$(json_escape "$key_contents")
    if [ -z "$ssh_json" ]; then
      ssh_json="\"$key_contents\""
    else
      ssh_json="$ssh_json,\"$key_contents\""
    fi
  done

  bootstrap_template=$(cat <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
user="__USERNAME__"
repo="__REPO_URL__"
ref="__REPO_REF__"
marker="/var/home/${user}/.cloud-native-bootstrapped"

[ -e "$marker" ] && exit 0

mkdir -p "$(dirname "$marker")"

if ! command -v podman >/dev/null 2>&1; then
  echo "podman not found; cannot bootstrap" >&2
  exit 1
fi

# Clone using a container so we don't need git on the host.
# Keep it simple: install git in the container, clone, checkout ref.
podman run --rm \
  -v "/var/home/${user}:/target" \
  docker.io/library/fedora:41 \
  bash -lc "dnf -y install git ca-certificates >/dev/null && rm -rf /target/cloud-native && git clone --depth 1 --branch \"$ref\" \"$repo\" /target/cloud-native"

chown -R "${user}:${user}" "/var/home/${user}/cloud-native" || true

touch "$marker"
EOF
)

  esc_user=$(escape_for_dq "$USERNAME")
  esc_repo=$(escape_for_dq "$REPO_URL")
  esc_ref=$(escape_for_dq "$REPO_REF")
  bootstrap_script=${bootstrap_template//__USERNAME__/$esc_user}
  bootstrap_script=${bootstrap_script//__REPO_URL__/$esc_repo}
  bootstrap_script=${bootstrap_script//__REPO_REF__/$esc_ref}

  unit_contents=$(cat <<EOF
[Unit]
Description=Bootstrap cloud-native desktop kit
Wants=network-online.target
After=network-online.target
ConditionPathExists=!/var/home/${USERNAME}/.cloud-native-bootstrapped

[Service]
Type=oneshot
ExecStart=/usr/local/bin/cloud-native-bootstrap

[Install]
WantedBy=multi-user.target
EOF
)

  bootstrap_b64=$(printf "%s" "$bootstrap_script" | b64_file /dev/stdin)

  hostname_file=""
  if [ -n "$HOSTNAME" ]; then
    hn_b64=$(printf "%s\n" "$HOSTNAME" | b64_file /dev/stdin)
    hostname_file=$(cat <<EOF
    ,{
      "path": "/etc/hostname",
      "mode": 420,
      "contents": {"source": "data:;base64,${hn_b64}"}
    }
EOF
)
  fi

  cat >"$OUT_DIR/ignition.json" <<EOF
{
  "ignition": {"version": "3.4.0"},
  "passwd": {
    "users": [
      {
        "name": "$(json_escape "$USERNAME")",
        "groups": ["wheel"],
        "passwordHash": "$(json_escape "$PASSWORD_HASH")",
        "sshAuthorizedKeys": [${ssh_json}]
      }
    ]
  },
  "storage": {
    "files": [
      {
        "path": "/usr/local/bin/cloud-native-bootstrap",
        "mode": 493,
        "contents": {"source": "data:;base64,${bootstrap_b64}"}
      }${hostname_file}
    ]
  },
  "systemd": {
    "units": [
      {
        "name": "cloud-native-bootstrap.service",
        "enabled": true,
        "contents": "$(json_escape "$unit_contents")"
      }
    ]
  }
}
EOF

  log "wrote $OUT_DIR/ignition.json"
}

build_raw_image() {
  img="$OUT_DIR/fcos-usb.img"

  ensure_commands truncate

  if [ "$(id -u)" -ne 0 ] && ! have sudo; then
    die "building a raw image requires root; re-run as root or install sudo"
  fi

  log "creating disk image: ${DISK_SIZE_GIB}GiB"
  mkdir -p "$OUT_DIR"
  truncate -s "${DISK_SIZE_GIB}G" "$img"
  [ -f "$img" ] || die "failed to create disk image at $img"
  img_real=$(realpath -m "$img")

  if have coreos-installer; then
    ensure_commands losetup

    if [ ! -e /dev/loop-control ]; then
      log "/dev/loop-control missing; attempting to load loop module via sudo modprobe loop"
      sudo_maybe modprobe loop || die "loop device support not available; ensure /dev/loop-control exists"
    fi

    # Ensure basic loop device nodes exist (/dev/loop0..7). Some hosts ship only loop-control.
    if ! ls /dev/loop0 >/dev/null 2>&1; then
      for i in $(seq 0 7); do
        dev="/dev/loop${i}"
        if [ ! -e "$dev" ]; then
          sudo_maybe mknod "$dev" b 7 "$i" || true
          sudo_maybe chmod 660 "$dev" || true
        fi
      done
    fi

    if ! sudo_maybe test -f "$img_real"; then
      die "disk image vanished before losetup: $img_real"
    fi

    loopdev=$(sudo_maybe sh -c "losetup --find --show \"$img_real\" 2>/tmp/losetup.err" ) || {
      err_msg=$(cat /tmp/losetup.err 2>/dev/null || true)
      rm -f /tmp/losetup.err
      die "failed to set up loop device for $img_real: ${err_msg:-unknown error}"
    }
    rm -f /tmp/losetup.err
    trap 'sudo_maybe losetup -d "$loopdev" >/dev/null 2>&1 || true' RETURN

    log "installing FCOS to $loopdev (stream=$STREAM arch=$ARCH platform=$PLATFORM) via local coreos-installer"
    sudo_maybe coreos-installer install "$loopdev" \
      --stream "$STREAM" \
      --architecture "$ARCH" \
      --platform "$PLATFORM" \
      --ignition-file "$OUT_DIR/ignition.json"
  else
    if [ "$(id -u)" -ne 0 ]; then
      if have sudo; then
        PODMAN="sudo podman"
      else
        die "coreos-installer missing: install it or rerun with sudo so we can use the container fallback"
      fi
    else
      PODMAN="podman"
    fi
    ensure_commands losetup podman

    if [ ! -e /dev/loop-control ]; then
      log "/dev/loop-control missing; attempting to load loop module via sudo modprobe loop"
      sudo_maybe modprobe loop || die "loop device support not available; ensure /dev/loop-control exists"
    fi
    if ! ls /dev/loop0 >/dev/null 2>&1; then
      for i in $(seq 0 7); do
        dev="/dev/loop${i}"
        if [ ! -e "$dev" ]; then
          sudo_maybe mknod "$dev" b 7 "$i" || true
          sudo_maybe chmod 660 "$dev" || true
        fi
      done
    fi

    loopdev=$(sudo_maybe sh -c "losetup --find --show \"$img_real\" 2>/tmp/losetup.err" ) || {
      err_msg=$(cat /tmp/losetup.err 2>/dev/null || true)
      rm -f /tmp/losetup.err
      die "container fallback: failed to set up loop device for $img_real: ${err_msg:-unknown error}"
    }
    rm -f /tmp/losetup.err
    trap 'sudo_maybe losetup -d "$loopdev" >/dev/null 2>&1 || true' RETURN

    log "installing FCOS via containerized coreos-installer (loop=$loopdev)"
    $PODMAN run --pull=always --privileged --rm \
      --security-opt label=disable \
      --device "$loopdev" \
      -v /dev:/dev \
      -v /run/udev:/run/udev \
      -v "$OUT_DIR":/data:z \
      quay.io/coreos/coreos-installer:release \
      install "$loopdev" \
        --stream "$STREAM" \
        --architecture "$ARCH" \
        --platform "$PLATFORM" \
        --ignition-file /data/ignition.json
  fi

  sudo_maybe sync
  if [ -n "${loopdev:-}" ]; then
    sudo_maybe losetup -d "$loopdev"
    trap - RETURN
  fi

  log "wrote $img"
}

run_qemu() {
  local img="$OUT_DIR/fcos-usb.img"
  [ -f "$img" ] || die "QEMU requested but image missing: $img"

  cmd=(
    "$SCRIPT_DIR/fcos-usb-qemu"
    --image "$img"
    --memory "$QEMU_MEM_MB"
    --cpus "$QEMU_CPUS"
    --name "$QEMU_NAME"
    --ssh-port "$QEMU_SSH_PORT"
  )
  [ "$QEMU_GUI" -eq 1 ] && cmd+=(--gui)
  [ "$QEMU_NO_KVM" -eq 1 ] && cmd+=(--no-kvm)
  [ "$QEMU_NO_SNAPSHOT" -eq 1 ] && cmd+=(--no-snapshot)
  if [ "${#QEMU_EXTRA[@]}" -gt 0 ]; then
    cmd+=(-- "${QEMU_EXTRA[@]}")
  fi

  log "launching QEMU (image=$(basename "$img"), mem=${QEMU_MEM_MB}MB, cpus=$QEMU_CPUS, ssh_port=$QEMU_SSH_PORT)"
  "${cmd[@]}"
}

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help) usage;;
    --out) OUT_DIR=$2; shift 2;;
    --stream) STREAM=$2; shift 2;;
    --arch) ARCH=$2; shift 2;;
    --platform) PLATFORM=$2; shift 2;;
    --size-gib) DISK_SIZE_GIB=$2; shift 2;;
    --user) USERNAME=$2; shift 2;;
    --hostname) HOSTNAME=$2; shift 2;;
    --ssh-key) SSH_KEYS+=("$2"); shift 2;;
    --password) PROMPT_PASSWORD=1; shift;;
    --password-hash) PASSWORD_HASH=$2; shift 2;;
    --repo) REPO_URL=$2; shift 2;;
    --ref) REPO_REF=$2; shift 2;;
    --no-build) DO_BUILD=0; shift;;
    --run-qemu) RUN_QEMU=1; shift;;
    --qemu-gui) QEMU_GUI=1; shift;;
    --qemu-no-kvm) QEMU_NO_KVM=1; shift;;
    --qemu-no-snapshot) QEMU_NO_SNAPSHOT=1; shift;;
    --qemu-ssh-port) QEMU_SSH_PORT=$2; shift 2;;
    --qemu-memory) QEMU_MEM_MB=$2; shift 2;;
    --qemu-cpus) QEMU_CPUS=$2; shift 2;;
    --qemu-name) QEMU_NAME=$2; shift 2;;
    --) shift; QEMU_EXTRA=("$@"); break;;
    *) usage;;
  esac
done

if [ -z "$OUT_DIR" ]; then
  OUT_DIR="$PWD/out/fcos-usb-${USERNAME}"
fi

if ! [[ "$DISK_SIZE_GIB" =~ ^[0-9]+$ ]] || [ "$DISK_SIZE_GIB" -le 0 ]; then
  die "--size-gib must be a positive integer (got: $DISK_SIZE_GIB)"
fi
if ! [[ "$QEMU_MEM_MB" =~ ^[0-9]+$ ]] || [ "$QEMU_MEM_MB" -le 0 ]; then
  die "--qemu-memory must be a positive integer (got: $QEMU_MEM_MB)"
fi
if ! [[ "$QEMU_CPUS" =~ ^[0-9]+$ ]] || [ "$QEMU_CPUS" -le 0 ]; then
  die "--qemu-cpus must be a positive integer (got: $QEMU_CPUS)"
fi
if ! [[ "$QEMU_SSH_PORT" =~ ^[0-9]+$ ]] || [ "$QEMU_SSH_PORT" -lt 0 ]; then
  die "--qemu-ssh-port must be a non-negative integer (got: $QEMU_SSH_PORT)"
fi
if [ "$RUN_QEMU" -eq 1 ] && [ "$DO_BUILD" -eq 0 ]; then
  die "--run-qemu requires building the image; remove --no-build"
fi

if [ "$PROMPT_PASSWORD" -eq 1 ] && [ -z "$PASSWORD_HASH" ]; then
  prompt_password_hash
fi

write_ignition

if [ "$DO_BUILD" -eq 1 ]; then
  build_raw_image

  cat <<EOF

Next steps:
  1) Write the image to a USB drive (DESTROYING its contents):

     sudo dd if="$OUT_DIR/fcos-usb.img" of=/dev/sdX bs=4M conv=fsync status=progress

  2) Boot from the USB. On first boot it will clone:

     $REPO_URL (ref: $REPO_REF)

Troubleshooting:
  - If cloning fails, verify networking and re-run:
      sudo systemctl restart cloud-native-bootstrap.service
EOF
else
  cat <<EOF

Ignition generated at:
  $OUT_DIR/ignition.json

To build a bootable USB image, install coreos-installer and re-run without --no-build.
EOF
fi

if [ "$RUN_QEMU" -eq 1 ]; then
  run_qemu
fi
