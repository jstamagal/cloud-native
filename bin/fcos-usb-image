#!/usr/bin/env bash
# Build a bootable Fedora CoreOS raw disk image and (optionally) boot it in QEMU.
# Root is required (for losetup inside a privileged podman container).

set -euo pipefail
set -x
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)
# shellcheck source=../lib/common.sh disable=SC1091
. "$SCRIPT_DIR/../lib/common.sh"

OUT_DIR=""
STREAM="stable"
ARCH="x86_64"
PLATFORM="metal"
DISK_SIZE_GIB=16
USERNAME="${SUDO_USER:-${USER:-core}}"
HOSTNAME=""
REPO_URL="https://github.com/jstamagal/cloud-native.git"
REPO_REF="main"
PASSWORD_HASH=""
PROMPT_PASSWORD=0
SSH_KEYS=()
DO_BUILD=1
RUN_QEMU=0
QEMU_GUI=0
QEMU_NO_KVM=0
QEMU_NO_SNAPSHOT=0
QEMU_SSH_PORT=2222
QEMU_MEM_MB=4096
QEMU_CPUS=4
QEMU_NAME="fcos-usb-debug"
QEMU_EXTRA=()

usage() {
  cat <<EOF
fcos-usb-image [options]

Creates a bootable FCOS raw disk image suitable for writing to a USB stick.
Root is required. We use the official coreos-installer container (podman --privileged)
so you don't need the binary on the host.

Options:
  --out DIR               output directory (default: ./out/fcos-usb-<user>)
  --stream NAME           FCOS stream (default: stable)
  --arch ARCH             target arch (default: x86_64)
  --platform NAME         ignition platform id (default: metal)
  --size-gib N            disk image size in GiB (default: 16)

  --user NAME             username to create (default: $USERNAME)
  --hostname NAME         optional hostname to set
  --ssh-key PATH          add SSH public key file (repeatable)

  --password              prompt for a login password and hash it (requires openssl)
  --password-hash HASH    provide an existing password hash

  --repo URL              repo to clone on first boot (default: $REPO_URL)
  --ref REF               git ref/branch to checkout (default: $REPO_REF)

  --no-build              only generate ignition.json; do not build a raw image

QEMU helpers (when --run-qemu is set):
  --run-qemu              launch QEMU after building the image
  --qemu-gui              open a QEMU display window (default: console)
  --qemu-no-kvm           force TCG (software) if KVM is unavailable
  --qemu-no-snapshot      persist writes to the base image (default: snapshot=on)
  --qemu-ssh-port PORT    host port forwarded to guest 22 (default: $QEMU_SSH_PORT, 0 disables)
  --qemu-memory MB        guest RAM in MiB (default: $QEMU_MEM_MB)
  --qemu-cpus N           vCPUs (default: $QEMU_CPUS)
  --qemu-name NAME        QEMU VM/process name (default: $QEMU_NAME)
  --                      pass remaining args straight to bin/fcos-usb-qemu

Notes:
  - Root required (losetup inside podman --privileged).
  - Host does NOT need coreos-installer; we pull quay.io/coreos/coreos-installer:release.
EOF
  exit 1
}

prompt_password_hash() {
  ensure_commands openssl stty
  pass1=""
  pass2=""
  printf "Password for %s: " "$USERNAME" >&2
  stty -echo </dev/tty
  IFS= read -r pass1 </dev/tty
  stty echo </dev/tty
  printf "\n" >&2

  printf "Confirm password: " >&2
  stty -echo </dev/tty
  IFS= read -r pass2 </dev/tty
  stty echo </dev/tty
  printf "\n" >&2

  [ "$pass1" = "$pass2" ] || die "passwords did not match"
  [ -n "$pass1" ] || die "empty password not allowed"
  PASSWORD_HASH=$(printf "%s\n" "$pass1" | openssl passwd -6 -stdin)
}

add_default_ssh_keys() {
  [ "${#SSH_KEYS[@]}" -gt 0 ] && return 0

  # Prefer the invoking user's keys (sudo), then the target user, then root.
  shopt -s nullglob
  candidates=()

  if [ -n "${SUDO_USER:-}" ]; then
    sudo_home=$(getent passwd "$SUDO_USER" 2>/dev/null | awk -F: '{print $6}')
    [ -z "$sudo_home" ] && sudo_home=$(eval echo "~$SUDO_USER" 2>/dev/null || true)
    [ -n "$sudo_home" ] && candidates+=("$sudo_home/.ssh")
  fi

  user_home=$(getent passwd "$USERNAME" 2>/dev/null | awk -F: '{print $6}')
  [ -z "$user_home" ] && user_home=$(eval echo "~$USERNAME" 2>/dev/null || true)
  [ -n "$user_home" ] && candidates+=("$user_home/.ssh")

  candidates+=("${HOME:-/root}/.ssh")

  for dir in "${candidates[@]}"; do
    for f in "$dir"/*.pub; do
      [ -f "$f" ] && SSH_KEYS+=("$f")
    done
  done
  shopt -u nullglob
}

dedup_ssh_keys() {
  # Remove duplicate key contents while preserving order.
  declare -A seen=()
  uniq_keys=()
  for k in "${SSH_KEYS[@]}"; do
    [ -f "$k" ] || continue
    content=$(cat "$k")
    if [ -z "${seen[$content]+x}" ]; then
      seen[$content]=1
      uniq_keys+=("$k")
    fi
  done
  SSH_KEYS=("${uniq_keys[@]}")
}

json_escape() {
  s=$1
  s=${s//\\/\\\\}; s=${s//\"/\\\"}; s=${s//$'\n'/\\n}; s=${s//$'\r'/\\r}; s=${s//$'\t'/\\t}
  printf "%s" "$s"
}

escape_for_dq() {
  local s=${1//\\/\\\\}
  s=${s//\"/\\\"}
  printf "%s" "$s"
}

b64_file() {
  if base64 --help 2>/dev/null | grep -q -- "-w"; then base64 -w0 "$1"; else base64 "$1" | tr -d '\n'; fi
}

write_ignition() {
  log "[ignition] building ignition"
  mkdir -p "$OUT_DIR"
  add_default_ssh_keys
  dedup_ssh_keys
  [ "${#SSH_KEYS[@]}" -gt 0 ] || die "no SSH public keys found; pass --ssh-key ~/.ssh/id_ed25519.pub"
  log "[ignition] using SSH keys: ${SSH_KEYS[*]}"
  [ -n "$PASSWORD_HASH" ] || die "password hash missing (use --password or --password-hash)"

  ssh_json=""
  for k in "${SSH_KEYS[@]}"; do
    [ -f "$k" ] || die "ssh key not found: $k"
    key_contents=$(json_escape "$(cat "$k")")
    ssh_json="${ssh_json:+$ssh_json,}\"$key_contents\""
  done

  bootstrap_template=$(cat <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
user="__USERNAME__"
repo="__REPO_URL__"
ref="__REPO_REF__"
marker="/var/home/${user}/.cloud-native-bootstrapped"
[ -e "$marker" ] && exit 0
mkdir -p "$(dirname "$marker")"
podman run --rm -v "/var/home/${user}:/target" docker.io/library/fedora:41 \
  bash -lc "dnf -y install git ca-certificates >/dev/null && rm -rf /target/cloud-native && git clone --depth 1 --branch \"$ref\" \"$repo\" /target/cloud-native"
chown -R "${user}:${user}" "/var/home/${user}/cloud-native" || true
touch "$marker"
EOF
)
  esc_user=$(escape_for_dq "$USERNAME")
  esc_repo=$(escape_for_dq "$REPO_URL")
  esc_ref=$(escape_for_dq "$REPO_REF")
  bootstrap_script=${bootstrap_template//__USERNAME__/$esc_user}
  bootstrap_script=${bootstrap_script//__REPO_URL__/$esc_repo}
  bootstrap_script=${bootstrap_script//__REPO_REF__/$esc_ref}

  unit_contents=$(cat <<EOF
[Unit]
Description=Bootstrap cloud-native desktop kit
Wants=network-online.target
After=network-online.target
ConditionPathExists=!/var/home/${USERNAME}/.cloud-native-bootstrapped

[Service]
Type=oneshot
ExecStart=/usr/local/bin/cloud-native-bootstrap

[Install]
WantedBy=multi-user.target
EOF
)

  bootstrap_b64=$(printf "%s" "$bootstrap_script" | b64_file /dev/stdin)
  hostname_file=""
  if [ -n "$HOSTNAME" ]; then
    hn_b64=$(printf "%s\n" "$HOSTNAME" | b64_file /dev/stdin)
    hostname_file=$(cat <<EOF
    ,{
      "path": "/etc/hostname",
      "mode": 420,
      "contents": {"source": "data:;base64,${hn_b64}"}
    }
EOF
)
  fi

  cat >"$OUT_DIR/ignition.json" <<EOF
{
  "ignition": {"version": "3.4.0"},
  "passwd": {
    "users": [
      {
        "name": "$(json_escape "$USERNAME")",
        "groups": ["wheel"],
        "passwordHash": "$(json_escape "$PASSWORD_HASH")",
        "sshAuthorizedKeys": [${ssh_json}]
      }
    ]
  },
  "storage": {
    "files": [
      {
        "path": "/usr/local/bin/cloud-native-bootstrap",
        "mode": 493,
        "contents": {"source": "data:;base64,${bootstrap_b64}"}
      }${hostname_file}
    ]
  },
  "systemd": {
    "units": [
      {
        "name": "cloud-native-bootstrap.service",
        "enabled": true,
        "contents": "$(json_escape "$unit_contents")"
      }
    ]
  }
}
EOF

  log "wrote $OUT_DIR/ignition.json"
  log "[ignition] done"
}

validate_ignition() {
  log "[validate] validating ignition via coreos-installer (container)"
  podman run --pull=always --rm -v "$OUT_DIR":/data:z \
    --entrypoint /bin/sh \
    quay.io/coreos/coreos-installer:release \
    -c 'set -euo pipefail
if coreos-installer ignition --help >/dev/null 2>&1; then
  coreos-installer ignition validate /data/ignition.json
  echo "[validate] ignition ok"
else
  echo "[validate] WARNING: installer image lacks ignition validate; skipped"
fi'
}

install_image() {
  img_real=$(realpath -m "$OUT_DIR/fcos-usb.img")
  log "[1/3] allocating disk image ($DISK_SIZE_GIB GiB) at $img_real"
  truncate -s "${DISK_SIZE_GIB}G" "$img_real"

  log "[2/3] installing FCOS via coreos-installer container"
  log "[2/3] podman pull/run: quay.io/coreos/coreos-installer:release"
  podman run --pull=always --privileged --rm \
    --security-opt label=disable \
    -v /dev:/dev \
    -v /run/udev:/run/udev \
    -v "$OUT_DIR":/data:z \
    --entrypoint /bin/sh \
    quay.io/coreos/coreos-installer:release \
    -c 'set -euo pipefail
echo "inside container: attaching loop (partscan) for /data/fcos-usb.img"
loop=$(losetup --find --show --partscan /data/fcos-usb.img)
trap "losetup -d $loop || true" EXIT
echo "inside container: loop=$loop; running coreos-installer"
coreos-installer install "$loop" \
  --stream '"$STREAM"' \
  --architecture '"$ARCH"' \
  --platform '"$PLATFORM"' \
  --ignition-file /data/ignition.json
sync'

  log "[3/3] image ready: $img_real"
}

run_qemu() {
  local img="$OUT_DIR/fcos-usb.img"
  [ -f "$img" ] || die "QEMU requested but image missing: $img"

  cmd=(
    "$SCRIPT_DIR/fcos-usb-qemu"
    --image "$img"
    --memory "$QEMU_MEM_MB"
    --cpus "$QEMU_CPUS"
    --name "$QEMU_NAME"
    --ssh-port "$QEMU_SSH_PORT"
  )
  [ "$QEMU_GUI" -eq 1 ] && cmd+=(--gui)
  [ "$QEMU_NO_KVM" -eq 1 ] && cmd+=(--no-kvm)
  [ "$QEMU_NO_SNAPSHOT" -eq 1 ] && cmd+=(--no-snapshot)
  if [ "${#QEMU_EXTRA[@]}" -gt 0 ]; then
    cmd+=(-- "${QEMU_EXTRA[@]}")
  fi

  log "[qemu] launching (image=$(basename "$img"), mem=${QEMU_MEM_MB}MB, cpus=$QEMU_CPUS, ssh_port=$QEMU_SSH_PORT)"
  exec "${cmd[@]}"
}

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help) usage;;
    --out) OUT_DIR=$2; shift 2;;
    --stream) STREAM=$2; shift 2;;
    --arch) ARCH=$2; shift 2;;
    --platform) PLATFORM=$2; shift 2;;
    --size-gib) DISK_SIZE_GIB=$2; shift 2;;
    --user) USERNAME=$2; shift 2;;
    --hostname) HOSTNAME=$2; shift 2;;
    --ssh-key) SSH_KEYS+=("$2"); shift 2;;
    --password) PROMPT_PASSWORD=1; shift;;
    --password-hash) PASSWORD_HASH=$2; shift 2;;
    --repo) REPO_URL=$2; shift 2;;
    --ref) REPO_REF=$2; shift 2;;
    --no-build) DO_BUILD=0; shift;;
    --run-qemu) RUN_QEMU=1; shift;;
    --qemu-gui) QEMU_GUI=1; shift;;
    --qemu-no-kvm) QEMU_NO_KVM=1; shift;;
    --qemu-no-snapshot) QEMU_NO_SNAPSHOT=1; shift;;
    --qemu-ssh-port) QEMU_SSH_PORT=$2; shift 2;;
    --qemu-memory) QEMU_MEM_MB=$2; shift 2;;
    --qemu-cpus) QEMU_CPUS=$2; shift 2;;
    --qemu-name) QEMU_NAME=$2; shift 2;;
    --) shift; QEMU_EXTRA=("$@"); break;;
    *) usage;;
  esac
done

if [ -z "$OUT_DIR" ]; then
  OUT_DIR="$PWD/out/fcos-usb-${USERNAME}"
fi

[ "$(id -u)" -eq 0 ] || die "run this script with sudo (root required for losetup inside podman)"
have podman || die "podman is required"

# Begin logging after OUT_DIR is known so we can tee to a file.
mkdir -p "$OUT_DIR"
LOG_FILE="$OUT_DIR/build.log"
exec > >(tee -a "$LOG_FILE") 2>&1
log "[log] capturing to $LOG_FILE"

if ! [[ "$DISK_SIZE_GIB" =~ ^[0-9]+$ ]] || [ "$DISK_SIZE_GIB" -le 0 ]; then
  die "--size-gib must be a positive integer (got: $DISK_SIZE_GIB)"
fi
if [ "$PROMPT_PASSWORD" -eq 1 ] && [ -z "$PASSWORD_HASH" ]; then
  prompt_password_hash
fi

log "[prep] output dir: $OUT_DIR"
write_ignition
validate_ignition
log "[plan] build=$DO_BUILD run_qemu=$RUN_QEMU"

if [ "$DO_BUILD" -eq 1 ]; then
  install_image

  cat <<EOF

Image ready:
  $OUT_DIR/fcos-usb.img

To write to USB (DESTROYS target):
  sudo dd if="$OUT_DIR/fcos-usb.img" of=/dev/sdX bs=4M conv=fsync status=progress

First boot pulls:
  $REPO_URL (ref: $REPO_REF)
EOF
else
  log "ignition only; skipping image build (--no-build set)"
fi

if [ "$RUN_QEMU" -eq 1 ]; then
  run_qemu
fi
